Git шпора э
Система контроля версий, или VCS (SCM), — программа, позволяющая контролировать изменения в проекте.
Git — один из примеров системы контроля версий: он позволяет хранить, изменять и анализировать историю проекта.
Git — незаменимый в команде инструмент, ведь он помогает объединять результаты работы нескольких человек.

Узнать, где вы сейчас, поможет команда pwd.

Права супер пользователя sudo ; запустить предыдущую команду от имени суперпользователь sudo !! ; 




ОЧИСТИТЬ ОКНО ТЕРМИНАЛА команда clear



Перейти к домашней директории - нужно ввести команду cd и символ ~ — обозначение домашней директории

Вывести содержимое директории — ls

Просматривать содержимое вместе со скрытыми файлами и папками через ls -a.

Если в названии папки есть пробелы, при вводе нужно использовать кавычки.

Чтобы вернуться в родительскую директорию — то есть на уровень выше, — вместо названия папки нужно написать две точки: ..

Есть ещё одна команда с точкой. Чтобы обратиться к текущей директории, можно использовать . Но это нужно довольно редко — например, для запуска скриптов и программ, которые принимают папку в качестве параметра.

Также cd позволяет перемещаться сразу через несколько директорий. Для этого нужно разделить их названия знаком /.

Создать файл, нужно ввести в консоль команду touch с именем файла в качестве параметра и расширением.

Для создания директорий через терминал используют другую команду — mkdir
Можно создать целую структуру директорий одной командой с помощью флага -p. (В папке папка и т.д., прописывается через /)

Также можно использовать обе команды вместе с символом домашней директории (~ - тильда) или родительской директории (..). Например, команда mkdir ~/my-git-projects создаст папку my-git-projects внутри домашней директории.

Для копирования файлов через терминал существует команда cp (что копируем куда копируем при этом что копируем может быть несколько)


Для перемещения файла из одной директории в другую используется команда mv, при этом синтаксис аналогичен синтаксису cp.

Чтобы прочитать файл, в консоль нужно ввести cat

Чтобы удалить файл, нужно напечатать команду rm (удалить все файлы команда rm * - удалит все файлы; удалить файлы с определенным разрешением rm *.txt - к примеру)

Удалить папку можно командой rmdir

Удалить вместе со всем её содержимым, можно использовать команду rm -r

Выполнение сразу нескольких команд можно осуществлять через указание амперсандов (&&)

Ещё один способ использовать Tab при навигации в другую директорию. Если ввести cd с названием папки, а затем нажать Tab, в консоль в качестве подсказки выведутся все возможные пути.

Git config user.name "Daniil Rodionov" - указать в конфигурациях имя пользователя
Git config --global user.name "Daniil Rodionov" - указать в конфигурациях Везде имя пользователя
Git config user.email "Daniel-rus@mail.ru" - указать в конфигурациях почту пользователя
Git config --global user.email "Daniel-rus@mail.ru" - указать в конфигурациях Везде почту пользователя

Настройки Git хранит в файл .gitconfig в домашней директорки (~/.gitconfig) / либо вывести содержимое файлаgit config --list



Репозитории основы работы с гитхаб

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду git init (от англ. initialize — «инициализировать»).

«Разгитить» папку, если что-то пошло не так, — rm -rf .git
ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым
ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».
Если удалить .git, то вся история проекта будет стёрта без возможности восстановления

Проверить состояние репозитория — git status

Подготовить файлы к сохранению — git add / либо git add --all ( флаг --all  позволяет подготовить все файлы в репозитории) / Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены - git add .

Выполнить коммит — git commit с флагом -m , т.е.  git commit -m "first commit"  - присвоить комментарий к файлам из git add
У первого комета будет выведена информация root-commit - это самый первый кормит в ветке

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение. 

Просмотреть историю коммитов — git log




Ssh ключ


SSH — протокол, который обеспечивает безопасный обмен данными в сети и использует для этого ключи.
SSH-ключ — ваш виртуальный идентификатор в GitHub. Как ключ от квартиры, он позволяет получить доступ к GitHub-репозиторию. Также SSH используется для доступа к другим удалённым серверам.
SSH-ключ состоит из двух частей — публичной и приватной. Публичный ключ зашифрует данные, а приватный — расшифрует. Приватным ключом ни в коем случае нельзя делиться, иначе любой сможет расшифровать все ваши секреты!


По умолчанию директория с SSH-ключами находится в домашней директории пользователя. Перейдите в неё. Обычно SSH-ключи находятся в директории .ssh/. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды  ls -la .ssh/
Ищем файлы с похожими названиями id_rsa.pub , если есть то их все надо удалить

Чтобы взять код ключ, надо
Перейти в домашню директорию cd ~, потом в папку с ключами через cd .ssh
Далее просто, cat id_rsa.pub, это для для всех осей)), но у нас мак и поэтому: $ pbcopy < ~/.ssh/id_rsa.pub
команда pbcopy — она копирует поток данных в буфер обмена все содержимое файла

Проверить правильность ключа с помощью следующей команды 
ssh -T git@github.com




Back to repositary)

Привязать удалённый репозиторий к локальному — перейдите в каталог локального репозитория и введите команду  git remote add origin и далее url удаленного репозитория
Origin - это имя — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию

Убедиться, что репозитории связаны, — git remote -v
Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе

Отправить изменения на удалённый репозиторий — git push
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой: git push -u origin main


Получить сокращённый лог можно с помощью команды git log с флагом --oneline

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый). Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.




Статусы файлов в Git 

untracked (англ. «неотслеживаемый») 
 Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add. 


staged (англ. «подготовленный»)
  После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

(Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.)


tracked (англ. «отслеживаемый») 
 Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения. 

modified (англ. «изменённый») 
 Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается.



Внести правки в уже сделанный коммит с помощью опции --amend (от англ. amend — «исправить», «дополнить») у команды commit: git commit --amend. Работает только с последним коммитом (HEAD)
полнить коммит новыми файлами можно с помощью git commit --amend --no-edit. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.

Изменить сообщение коммита — git commit --amend -m "Новое сообщение"

Убрать файл из staging поможет команда git restore --staged <file>
Чтобы «сбросить» все файлы из staged обратно в untracked/modified, можно воспользоваться командой git restore --staged .: она сбросит всю текущую папку (.).

«Откатить» коммит — git reset --hard <commit hash>

Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в Changes not staged for commit (modified). Чтобы вернуть всё «как было», можно выполнить команду git restore <file>.

апустите git diff, чтобы выяснить детали. Эта команда сравнит последнюю закоммиченную версию файла с текущей (изменённой) версией.
Самое важное git diff выводит в конце:
красный цвет строки  значит, что эта строка была удалена;
зелёный цвет строки  значит, что она была добавлена.
Не все консоли умеют выводить цвета, поэтому строки помечаются не только цветом, но и знаком - или +. Минус — это удалённые строки, плюс — это добавленные.
*Передайте команде git diff хеши обоих коммитов. Состояние файлов на момент первого переданного коммита будет сравниваться с состоянием файлов на момент второго.
git diff --staged показывает, что изменилось в проиндексированных файлах.
Ключ --staged говорит системе, что нужно смотреть изменения, которые были добавлены в staged.


Дописываем строку в файл : Для этого подходит команда echo 
echo "Вторая строка файла" >> file.txt
если скомбинировать echo с символами перенаправления вывода >> (два знака «больше»), то всё, что должно было попасть на экран, вместо этого будет записано в файл.
Оператор >> — это возможность командной строки (Bash). Его можно использовать не только с echo, но и с любой другой командой, которая выводит что-то на экран.
Одинарный символ > тоже перенаправит вывод команды в файл, но перед этим сотрёт содержимое файла, то есть перезапишет файл целиком,  после использования символа > Первая строка файла исчезла.



Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов. В простейшем случае в .gitignore указывают все файлы, которые нужно игнорировать (по одному имени на строку). Но часто удобнее использовать шаблоны. Шаблон, или правило, — это способ указать сразу на несколько файлов с однотипными названиями.

Комментарий
Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.

Просто название файла
Допустим, нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла.

Звёздочка (*)

Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.

Вопросительный знак (?)
Вопросительный знак ? соответствует одному любому символу.

Квадратные скобки ([…])
Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.
В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z])

Слеш (/)
Косая черта, или слеш (/), указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.

Парные звёздочки (**)
Функция парных звёздочек (**) похожа на функцию одинарной (*). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.

Восклицательный знак (!)
Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.

Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.





Клонировать репозиторий — git clone


21_01
 
ВЕТКИ

Просмотреть ветки проекта — git branch
Создать ветку — git branch <название_ветки>
Название ветки в Git может состоять из букв, цифр, а также включать любой из четырёх символов: ., -, _, /
Переключиться на другую ветку — git checkout <название_ветки>
Создать ветку и сразу переключиться на неё — git checkout -b <название_ветки>
Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

Сравнить ветки — git diff <название_ветки1> <название_ветки2>


Git поддерживает суффикс навигации ~. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить git diff main~3 main.


Выполнить слияние веток позволяет команда git merge <название_ветки>. В качестве параметра указывают название ветки, которую нужно влить в текущую.
Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда git branch -D <название_ветки> и её щадящий вариант с флагом -d.

Загрузить ветку git push -u origin <название ветки> - необязательно переходить в ветку, чтобы запушить её.

PULL REQUEST
Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.
pull request и чем он может обернуться

У каждого пул-реквеста есть:
Название — краткое описание предлагаемых изменений. Например: Адаптивный заголовок сайта, Замена альбома на галерею и так далее.
Описание — развёрнутое описание изменений. Это поле заполнять необязательно, но желательно.
Исходная ветка — та, в которой вы работали. Например, feature/merge-request.
Целевая ветка — основная ветка проекта, в которую вы хотите внести изменения.
 Также у каждого пул-реквеста может быть два исхода:
merge (англ. «соединить») — предлагаемые изменения приняты; код вливается в целевую ветку; пул-реквест закрывается.
close (англ. «закрыть») — пул-реквест закрывается без слияния изменений.

Существует два способа.
Первый способ. При создании новой ветки в удалённом репозитории Git распечатает сообщение. Оно включает ссылку на создание пул-реквеста.

Второй способ. Чтобы создать пул-реквест для любой существующей ветки на GitHub, перейдите на страницу репозитория, а затем выберите вкладку Pull requests в верхней части экрана.

Далее Выбрать названия веток: ветка «откуда» (из которой будет происходить пул-реквест) и ветка «куда» (в которую он будет осуществлён)


Merge pull request (англ. «принять запрос на изменения») — это действие объединит ветку с вашими изменениями и ветку main.




Команда git pull позволяет подтянуть изменения из удалённого репозитория в локальный.
Перед созданием нового пул-реквеста считается хорошей практикой перейти в главную ветку, «подтянуть» в неё изменения, а затем добавить эти изменения в вашу ветку с помощью git merge main.
Отправить изменения, а также связать локальную и удалённую ветки поможет push -u.







Шпаргалка. Работа с ветками




В этой шпаргалке мы собрали все ключевые команды модуля — они наверняка пригодятся вам в реальной работе с ветками!
Клонирование чужого репозитория

git clone git@github.com:YandexPraktikum/first-project.git (от англ. clone, «клон», «копия») — склонируй репозиторий с URL first-project.git из аккаунта YandexPraktikum на мой локальный компьютер.
Создание веток

git branch feature/the-finest-branch (от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch;
git checkout -b feature/the-finest-branch — создай ветку feature/the-finest-branch и сразу переключись на неё.
Навигация по веткам

git branch (от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
git branch -a — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в origin, или на GitHub).
git checkout feature/br — переключись на ветку feature/br.
Сравнение веток

git diff main HEAD (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD;
git diff HEAD~2 HEAD — покажи разницу между тем коммитом, который был два коммита назад, и текущим.
Удаление веток

git branch -d br-name — удали ветку br-name, но только если она является частью main;
git branch -D br-name — удали ветку br-name, даже если она не объединена с main.
Слияние веток

git merge main (от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой. 
Работа с удалённым репозиторием

git push -u origin my-branch (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u;
git push my-branch — отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;
git pull (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.




Можно ли отключить fast-forward

Fast-forward слияние веток можно отключить флагом --no-ff. Например: git merge --no-ff add-docs. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») с помощью настройки merge.ff: git config [--global] merge.ff false.
Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния (англ. merge commit) — в обиходе его называют merge-коммит или мёрж-коммит. В этом случае результат «вливания» ветки add-docs в main выглядел бы так.
Многие проекты отключают fast-forward слияние веток, потому что при нём теряется часть информации. Результат выглядит так, как будто в main «просто появились» новые коммиты. Если не знать о ветке add-docs, то можно подумать, что такой ветки и не было.

git log --graph --oneline 
Покажет в таком виде :

* 17d096e (HEAD -> main, origin/third, third) 666
* 9246e7d 555
*   2dc0be0 Merge branch 'second'
|\  
| * 45875ec (origin/second, second) 444
| * c693e9d 333
|/  
* 4615ba8 (origin/main) 222
* 5fa1814 111


Состояние non-fast-forward
При слиянии не-fast-forward веток Git создаёт коммит слияния.
Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git». Для таких случаев удобен флаг --no-edit: git merge --no-edit %another_branch%.


При переносе с помощью git push из локального на удаленный терминал может быть аналогичное состояние non-fast-forward. В таких случаях при команде git push будет ошибка rejected: non-fast-forward. Чтобы обойти эту ошибку можно применить команду git push --force, НО!!!! Она сотрет тот коммит который есть на удаленном репозитории чтобы подстроиться



Модели веток
Существуют подходы для работы с ветками
Подходы (модели,стратегии) к работе с ветками — это правила, которые описывают, когда и для чего создаются ветки, какие в них коммиты и в какой момент происходит слияние веток.

Подходы

Рассмотрим три самых популярных подхода — их также принято называть workflow (англ. «рабочий процесс») или сокращённо: flow.
Feature branch workflow — простой и самый популярный вариант. Если коротко, в нём для каждого нового изменения создаётся новая ветка, которая позже вливается в main с помощью git merge.
Git flow — более сложный вариант. Подход похож на feature branch workflow, но в нём создаётся больше веток, а изменения (коммиты) делят на разные типы: исправление, новая функциональность и так далее. Разные типы коммитов попадают в разные ветки.
Trunk-based — популярный в больших компаниях (таких как Яндекс, Google и прочих) подход, который обещает бо́льшую скорость работы в крупных командах. Этот подход тоже похож на feature branch workflow. Главное отличие в том, что участники проекта вливают (merge) свой код в основную ветку максимально часто. Например, каждый день.

Feature branch workflow (В разных источниках можно встретить написания feature-based flow или feature-branch flow, а также варианты этого подхода GitHub flow и GitLab flow.)

Основная идея модели feature branch workflow (от англ. feature — «особенность», «деталь») в том, что работа над любой новой функциональностью или исправлением ведётся в отдельной ветке.
Если аккуратно следовать подходу feature branch workflow, то:
Не будет проблемы «расхождения» веток, ведь новые изменения попадают в main через git merge, а не через git push. Команду merge «разошедшиеся» ветки не смущают, ведь для них она и придумана.
В ветке main всегда рабочая версия проекта. Все «полуфабрикаты» и недоделанные функциональности находятся в feature-ветках, пока не будут готовы попасть в main.
О feature branch workflow коротко

Основные правила:
новая функциональность или исправление — новая ветка;
когда код в feature-ветке готов, он вливается в main;
в main всегда рабочая версия без «недоделок».
Преимущества:
простая модель;
позволяет работать с Git в команде без лишних технических сложностей.



*Чтобы связать локальную ветку с удалённой, используют команду git push --set-upstream origin HEAD. Флаг --set-upstream — это «полная», или «длинная», версия флага -u. А HEAD здесь — это синоним текущей ветки. С тем же результатом можно было бы выполнить команду git push -u origin feature-goose-poem.





Команды git gl не существует в Git. Это сокращённая запись, которую можно создать для любой команды через механизм alias (англ. «псевдоним»). Подробнее о нём можно почитать в документации (https://git-scm.com/book/ru/v2/Основы-Git-Псевдонимы-в-Git) .  
Вызов git gl превращается в вызов git log с несколькими параметрами: git log --oneline --abbrev-commit --graph --date=short --pretty=format:'%h - %an, %cd : %s'. У каждого флага своя функция. --abbrev-commit покажет только первые несколько символов из хеша коммита; --graph выведет результат в виде графа; --date=short выведет дату в формате yyyy-MM-dd, например 2023-07-12; --pretty=format:'%h - %an, %cd : %s' задаёт формат выдачи результата.



Чтобы разрешить конфликт слияния, который возникает, когда главная ветка «уходит» вперёд, можно сделать следующее. Сначала локально получить новые изменения через git pull, а затем выполнить git merge и разрешить конфликт. Далее создать коммит слияния и отправить новые изменения без конфликтов обратно в удалённый репозиторий командой git push.






Алгоритм-шпаргалка для создания PR

Склонировать репозиторий.
Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.
На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.
Выполнить команду git clone <ссылка на репозиторий>.
Создать ветку для вашей задачи: git checkout -b my-task-branch-name.
Добавить и «закоммитить» изменения, которые вы хотите внести в проект.
«Запушить» ветку: git push --set-upstream origin HEAD или git push -u origin my-task-branch-name.
GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.
PR можно также создать через интерфейс GitHub.
Сообщить о пул-реквесте ревьюеру.
Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.
Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).  
6.1. Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью, нужно разрешить конфликт:  
Обновить main: git checkout main && git pull.
Влить main в свою ветку: git checkout my-task-branch-name && git merge main.
Разрешить конфликты слияния с помощью IDE или вручную.
Создать коммит слияния: git commit --no-edit или git commit -m 'merge main'.
Сделать git push своей ветки.
Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.
Ещё раз обновить main, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: git checkout main && git pull.
Вы великолепны! Можете начинать снова со второго пункта.
Алгоритм-шпаргалка для разрешения конфликтов слияния

Открыть проект в IDE (VS Code, IDEA или другие).
Открыть файл, в котором есть конфликт.
Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.
Когда конфликты разрешены, сделать коммит: git commit --no-edit или git commit -m 'merge branch <название ветки>'.